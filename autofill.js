// Generated by CoffeeScript 1.8.0
(function() {
  define(['module', 'angular'], function(module, angular) {
    var css, directive, path;
    path = module.uri.replace(/[^\/]+$/, '');
    if (!document.getElementById('aseedAutofillCSS')) {
      css = document.createElement('link');
      css.rel = 'stylesheet';
      css.type = 'media/css';
      css.href = "" + path + "autofill.css";
      css.id = 'aseedAutofillCSS';
      document.getElementsByTagName('head')[0].appendChild(css);
    }
    return directive = function($http, $timeout) {
      return {
        templateUrl: "" + path + "autofill.html",
        restrict: 'EA',
        scope: {
          subset: '=',
          model: '=',
          callback: '=',
          filter: '=',
          url: '@',
          label: '@',
          show: '@'
        },
        link: function($scope, el, attrs) {
          var clearResults, maxCount, prevSearch, req, returnItem, search, selectedIndex, selectedItem, setSelectedItem, timer;
          selectedIndex = -1;
          selectedItem = null;
          maxCount = 10;
          if (typeof $scope.show !== 'undefined') {
            maxCount = Number($scope.show);
          }
          if (!maxCount) {
            maxCount = 10;
          }
          $scope.results = [];
          $scope.getLabel = function() {
            var i, k, obj, prop, _i, _ref;
            if (typeof $scope.label !== 'undefined' && $scope.label) {
              return this.result[$scope.label];
            }
            prop = ['title', 'name', 'label'];
            if (typeof $scope.model) {
              obj = new $scope.model(this.result);
            } else {
              obj = this.result;
            }
            if (typeof obj === 'string') {
              return obj;
            }
            if (typeof obj.getLabel === 'function') {
              return obj.getLabel();
            }
            for (i = _i = 0, _ref = prop.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              k = prop[i];
              if (typeof obj[k] !== 'undefined') {
                return obj[k].toString();
              }
            }
            return obj.toString();
          };
          clearResults = function() {
            var prevSearch, req, timer;
            $scope.results = [];
            $scope.search = '';
            prevSearch = '';
            timer = null;
            req = null;
            selectedIndex = -1;
            return selectedItem = null;
          };
          returnItem = function(item) {
            var o;
            o = item;
            if (typeof $scope.model !== 'undefined') {
              item = new $scope.model(item);
            }
            if (typeof $scope.ngModel !== 'undefined') {
              $scope.ngModel = item;
            }
            if (typeof $scope.callback !== 'undefined') {
              $scope.callback(item, o);
            }
            return clearResults();
          };
          prevSearch = '';
          timer = null;
          req = null;
          search = function() {
            var fn;
            if (timer) {
              $timeout.cancel(timer);
            }
            fn = function() {
              var i, item, k, regexp, term, v, _i, _ref;
              term = String($scope.search).replace(/^\s+/, '').replace(/\s+$/, '');
              if (term === prevSearch) {
                return;
              }
              if (!term) {
                clearResults();
                return;
              }
              prevSearch = term;
              if (typeof $scope.filter !== 'undefined') {
                $scope.results = $scope.filter(term, $scope.subset);
                return;
              }
              $scope.results = [];
              if (typeof $scope.subset !== 'undefined' && angular.isArray($scope.subset)) {
                regexp = new RegExp(term, 'i');
                for (i = _i = 0, _ref = $scope.subset.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  item = $scope.subset[i];
                  if (typeof item === 'string') {
                    if (item.match(regexp)) {
                      $scope.results.push(item);
                    }
                  } else {
                    for (k in item) {
                      v = item[k];
                      if (typeof v === 'object' || typeof v === 'function') {
                        continue;
                      }
                      if (v.toString().match(regexp)) {
                        $scope.results.push(item);
                        break;
                      }
                    }
                  }
                  if ($scope.results.length > maxCount) {
                    return;
                  }
                }
              }
            };
            return timer = $timeout(fn, 100);
          };
          $scope.keydown = function(e) {
            switch (e.keyCode) {
              case 13:
                if (selectedItem) {
                  returnItem(selectedItem);
                }
                return true;
              case 27:
                clearResults();
                el.find('input')[0].blur();
                return true;
              case 38:
                selectedIndex--;
                break;
              case 40:
                selectedIndex++;
                break;
              default:
                search();
                return true;
            }
            setSelectedItem();
            return e.preventDefault();
          };
          $scope.selectItem = function() {
            returnItem(this.result);
            return clearResults();
          };
          setSelectedItem = function() {
            var minValue;
            minValue = 0;
            if (selectedIndex < minValue) {
              selectedIndex = $scope.results.length - 1;
            }
            if (selectedIndex >= $scope.results.length) {
              selectedIndex = minValue;
            }
            return selectedItem = $scope.results[selectedIndex];
          };
          return $scope.isSelected = function() {
            return this.result === selectedItem;
          };
        }
      };
    };
  });

}).call(this);

//# sourceMappingURL=autofill.js.map
